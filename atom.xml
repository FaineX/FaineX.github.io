<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://FaineX.github.io</id>
    <title>For XeniaF</title>
    <updated>2021-07-14T12:27:09.670Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://FaineX.github.io"/>
    <link rel="self" href="https://FaineX.github.io/atom.xml"/>
    <subtitle>(☆▽☆)</subtitle>
    <logo>https://FaineX.github.io/images/avatar.png</logo>
    <icon>https://FaineX.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, For XeniaF</rights>
    <entry>
        <title type="html"><![CDATA[网络流]]></title>
        <id>https://FaineX.github.io/post/wang-luo-liu/</id>
        <link href="https://FaineX.github.io/post/wang-luo-liu/">
        </link>
        <updated>2021-07-14T11:44:55.000Z</updated>
        <content type="html"><![CDATA[<p>题目汇总。</p>
<hr>
<h2 id="最小割">最小割</h2>
<h4 id="p2598-zjoi2009狼和羊的故事">P2598 [ZJOI2009]狼和羊的故事</h4>
<blockquote>
<ul>
<li>修建栏杆相当于是割断了狼和羊之间的联系方式，即割掉了一条边。<strong>在网格图中，建边的方式为由现在所在的格子向周围四个方向的格子连一条边。</strong>（理论上建立反向边比较赘余，但是因为在跑 Dinic 过程中涉及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>（本条边）和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∧</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i \land 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（反向边）的使用，所以建。)因此，在网络流中，要求割最少的边，使得网络不流通，为<strong>网络流最小割问题</strong>。需要用到的定理为：最小割<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span>最大流。建图以后跑 Dinic 就好了。</li>
<li>最小割问题指的是，割去一些边之后，源点到汇点不再流通。这里要求一定要把狼和羊严格隔开，距离无法隔开他们，也就是说即使他们隔着很多个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的格子，也是可以互相到达的！这就不满足题目条件了。</li>
</ul>
</blockquote>
<h4 id="p2774-方格取数问题">P2774 方格取数问题</h4>
<blockquote>
<ul>
<li>奇数点放一边，偶数点放一边，建立二分图。建完边后，考虑继续连边，将所有可能产生影响的边连接在一起，这里只要把黑点连向白点就可以了。因为最开始在构建这个网络流的时候，方向已经定为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>-&gt;黑-&gt;白-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>了。</li>
<li>如果只看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的奇偶性的话会出问题，因为就相当于不会影响上下的格子。</li>
</ul>
</blockquote>
<h4 id="cf1198e-rectangle-painting-2">CF1198E Rectangle Painting 2</h4>
<blockquote>
<ul>
<li>把一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>∗</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">h*w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的矩形区域覆盖的代价是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\min(h,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>，因此选择一个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">1*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的区间显然非常优秀。如果多个区间可以合并的话，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>显然代价等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">n* \min(1,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k* \min(n,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，并且数据中区间所占行数和列数离散化后又不是很多，因此可以这么做！</li>
<li>关于离散化<br>
1）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>x</mi><mi>n</mi><mi mathvariant="normal">，</mi><mi>u</mi><mi>y</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">uxn，uyn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">n</span></span></span></span>保存的是离散化后数组总个数，不是最大值；<br>
2）通过画图可以发现，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>u</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ux[i+1]-ux[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>确实包含了所有的矩形，但是有可能把把两个矩形切成三个矩形；<br>
3）至于为什么要变作闭右开区间，因为这样确实可以很好的覆盖所有的数，是一种技巧。</li>
<li>关于最小覆盖<br>
在这个题目中，最小覆盖=最小割=最大流。</li>
</ul>
</blockquote>
<hr>
<h2 id="最小费用最大流">最小费用最大流</h2>
<h4 id="p3159-cqoi2012交换棋子">P3159 [CQOI2012]交换棋子</h4>
<blockquote>
<ul>
<li>题目涉及黑白棋子和两种状态，均考虑显然比较繁杂。暂且先不管白棋子和不变色的黑棋子，将所有初始状态就是黑棋子的点与源点相连，最终状态是黑棋子的点与汇点相连。因为黑棋子的交换可以看作移动，显然只有端点只交换了一次其他中间点交换了两次因此建边时流量应<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>。</li>
<li>建边方式如下：<br>
1）连源汇，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，表示有待匹配；<br>
2）中间点，初始状态与最终状态相连，流量为交换次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>，费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；<br>
3）初始状态与最终状态不同，且可交换次数为奇数的黑棋，单独向最终状态连一条边，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；<br>
4）处理格点，向八个方向连边，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即交换需要付出的代价。</li>
<li>跑模板即可。</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3159 [CQOI2012]交换棋子]]></title>
        <id>https://FaineX.github.io/post/p3159-cqoi2012jiao-huan-qi-zi/</id>
        <link href="https://FaineX.github.io/post/p3159-cqoi2012jiao-huan-qi-zi/">
        </link>
        <updated>2021-07-14T11:42:53.000Z</updated>
        <content type="html"><![CDATA[<p>最小费用最大流。</p>
<p>题目涉及黑白棋子和两种状态，均考虑显然比较繁杂。暂且先不管白棋子和不变色的黑棋子，将所有初始状态就是黑棋子的点与源点相连，最终状态是黑棋子的点与汇点相连。因为黑棋子的交换可以看作移动，显然只有端点只交换了一次其他中间点交换了两次因此建边时流量应<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>。<br>
建边方式如下：<br>
1）连源汇，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，表示有待匹配；<br>
2）中间点，初始状态与最终状态相连，流量为交换次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>，费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；<br>
3）初始状态与最终状态不同，且可交换次数为奇数的黑棋，单独向最终状态连一条边，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；<br>
4）处理格点，向八个方向连边，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即交换需要付出的代价。<br>
跑模板即可。</p>
<p>注意：<br>
1）依然是数组大小！<br>
2）费用流基本上就是用 spfa 代替了 bfs ，每次通过 spfa 寻找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的最短路，再 dfs 不断增广。<br>
3）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>m</mi><mi mathvariant="normal">，</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sm，ct</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span></span></span></span>数组是用来拆点的，连边的流量就相当于是交换次数。能成功交换的交换次数一定是偶数的，因此如果是奇数那就应该补上原本就有的那次交换。</p>
<ul>
<li>设原来的交换次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2*a+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>后为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，实际上只会交换<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">2*a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>次，因此应该加边补上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ul>
<p>4）spfa 中的阶层直接由费用进行划分，由于是最短路初始值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，最终判断时也变为了是否等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><br>
5）dfs 中增加了一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">vit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>数组的判断操作，去掉会段错误（暂时不知道为什么<br>
6）玄学弧优化，然而我的出锅了...</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define maxn 5000
#define INF 1000000000000
using namespace std;
ll n,m,a[maxn][maxn],b[maxn][maxn],l[maxn][maxn];
ll si,ti;
ll s,t,p;
ll ff[15][3]={{0,1},{0,-1},{1,0},{-1,0},{-1,1},{1,-1},{1,1},{-1,-1}};
char c[maxn][maxn];
struct Node{
    ll nx,to,dis,val;
}e[maxn&lt;&lt;2];
ll cnt=1,hd[maxn];
ll vit[maxn],dep[maxn],cur[maxn];
ll ansf,anss;
queue&lt;ll&gt;q;

inline ll mn(ll u,ll v){
    return u&lt;v?u:v;
}

inline ll read(){
    ll x=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|=c=='-',c=getchar();
    while(isdigit(c))
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return f?-x:x;
}

inline void add(ll u,ll v,ll w,ll vl){
    e[++cnt].to=v;
    e[cnt].dis=w;
    e[cnt].val=vl;
    e[cnt].nx=hd[u];
    hd[u]=cnt;
}

inline ll sm(ll u,ll v){
    return (u-1)*m+v;
}

inline ll ct(ll u,ll v){
    return (u-1)*m+v+n*m;
}

inline int spfa(){
    for(register int i=1;i&lt;=p;++i)
        vit[i]=0,dep[i]=INF,cur[i]=hd[i];
    q.push(s);
    vit[s]=1,dep[s]=0;
    while(!q.empty()){
        ll u=q.front();q.pop();
        vit[u]=0;
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to,val=e[i].val;
            if(e[i].dis&amp;&amp;dep[to]&gt;dep[u]+val){
                dep[to]=dep[u]+val;
                if(!vit[to]){
                    vit[to]=1;
                    q.push(to);
                }
            }
        }
    }
    return (dep[t]!=INF);
}

inline ll dfs(ll u,ll limit){
    if(u==t)    return limit;
    ll flow=0,fj;
    vit[u]=1;
    for(register int i=hd[u];i;i=e[i].nx){
        ll to=e[i].to;
//        cur[u]=i;
        if((!vit[to]&amp;&amp;e[i].dis&amp;&amp;dep[u]+e[i].val==dep[to])&amp;&amp;(fj=dfs(to,mn(limit,e[i].dis)))&gt;0){
            e[i].dis-=fj;
            e[i^1].dis+=fj;
            flow+=fj;
            limit-=fj;
            if(!limit){
                vit[u]=0;
                break;
            }
        }
    }
    return flow;
}

int main(){
    n=read();m=read();
    s=t-1,p=t=2*n*m+2;
    for(register int i=1;i&lt;=n;++i){
        cin&gt;&gt;c[i];
        for(register int j=1;j&lt;=m;++j)
            a[i][j]=c[i][j-1]-'0',si+=(a[i][j]);
    }
    for(register int i=1;i&lt;=n;++i){
        cin&gt;&gt;c[i];
        for(register int j=1;j&lt;=m;++j)
            b[i][j]=c[i][j-1]-'0',ti+=(b[i][j]);
    }
    if(si!=ti){
        printf(&quot;-1\n&quot;);
        return 0;
    }
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            if(b[i][j]!=a[i][j])
                if(a[i][j])
                    add(s,sm(i,j),1,0),
                    add(sm(i,j),s,0,0),
                    ++ansf;
                else
                    add(ct(i,j),t,1,0), 
                    add(t,ct(i,j),0,0);
    for(register int i=1;i&lt;=n;++i){
        cin&gt;&gt;c[i];
        for(register int j=1;j&lt;=m;++j){
            l[i][j]=c[i][j-1]-'0';
            add(sm(i,j),ct(i,j),l[i][j]&gt;&gt;1,0),
            add(ct(i,j),sm(i,j),0,0);
            if((a[i][j]^b[i][j])&amp;&amp;(l[i][j]&amp;1))
                add(sm(i,j),ct(i,j),1,0),
                add(ct(i,j),sm(i,j),0,0);
            for(register int k=0;k&lt;=7;++k){
                ll dx=i+ff[k][0];
                ll dy=j+ff[k][1];
                if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m)
                    add(ct(i,j),sm(dx,dy),INF,1),
                    add(sm(dx,dy),ct(i,j),0,-1);
            }
        }
            
    }
    while(spfa()){
        ll tik=dfs(s,INF);
        ansf-=tik,anss+=tik*dep[t];
//        cout&lt;&lt;&quot;我好困呜呜呜\n&quot;;
//        cout&lt;&lt;&quot;ans: &quot;&lt;&lt;tik&lt;&lt;endl;
    }
    if(ansf)    puts(&quot;-1&quot;);
    else        printf(&quot;%lld\n&quot;,anss);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇怪的东西]]></title>
        <id>https://FaineX.github.io/post/qi-guai-de-dong-xi/</id>
        <link href="https://FaineX.github.io/post/qi-guai-de-dong-xi/">
        </link>
        <updated>2021-07-13T11:45:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>最大费用最大流</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2017 [USACO09DEC]Dizzy Cows G]]></title>
        <id>https://FaineX.github.io/post/p2017-usaco09decdizzy-cows-g/</id>
        <link href="https://FaineX.github.io/post/p2017-usaco09decdizzy-cows-g/">
        </link>
        <updated>2021-07-13T11:09:39.000Z</updated>
        <content type="html"><![CDATA[<p>拓扑排序。</p>
<blockquote>
<p>前言：感觉不像网络流或者二分图啊...不会是他们说错了吧啊啊啊，不管了。</p>
</blockquote>
<p>题目大意是要你找到一种定向方法，使图中不存在环。<br>
考虑拓扑排序。<br>
先将入读为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的点加入队列（此时并不考虑无向边），再进行拓扑。<br>
拓扑到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>点时，如果发现有一条无向边，就将它直接定向：现在节点为这条边的起点。</p>
<blockquote>
<p>关于这种做法的正确性<br>
“dfs完成拓扑排序，拓扑这个东西核心就是排序，排什么序呢，将无向图变成一个有向无环图（DAG），这个就是题目的要求吗，双边就不跑，只跑单边，把拓扑序找到，再依次判断方向。对于拓扑序来说，dfs后深度越浅的点，拓扑序越大，然后只将大的指向小的，就不会形成环了。“（@Zxsoul）</p>
</blockquote>
<p>注：</p>
<ul>
<li>使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∧</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a \land 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时注意<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>必须是奇数</li>
<li>当一道题目与 DAG（有向无环图）有关时，考虑拓扑排序。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1198E Rectangle Painting 2]]></title>
        <id>https://FaineX.github.io/post/cf1198e-rectangle-painting-2/</id>
        <link href="https://FaineX.github.io/post/cf1198e-rectangle-painting-2/">
        </link>
        <updated>2021-07-13T09:25:20.000Z</updated>
        <content type="html"><![CDATA[<p>网络流<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span>二分图最小覆盖。</p>
<p>把一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>∗</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">h*w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的矩形区域覆盖的代价是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\min(h,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>，因此选择一个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">1*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的区间显然非常优秀。如果多个区间可以合并的话，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>显然代价等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">n* \min(1,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k* \min(n,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，并且<s>数据中区间所占行数和列数离散化后又不是很多</s>，因此可以这么做！</p>
<hr>
<p>关于离散化</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>x</mi><mi>n</mi><mi mathvariant="normal">，</mi><mi>u</mi><mi>y</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">uxn，uyn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">n</span></span></span></span>保存的是离散化后数组总个数，不是最大值</li>
<li>通过画图可以发现，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>u</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ux[i+1]-ux[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>确实包含了所有的矩形，但是有可能把把两个矩形切成三个矩形</li>
<li>然然后为什么要变作闭右开区间呢，因为这样确实可以很好的覆盖所有的数，自己模拟吧（），但这真的是个技巧欸</li>
</ul>
<p>我居然看懂了！/fad</p>
<hr>
<p>关于数据范围<br>
首先这个500就很玄学啊（我死都不会说我看了题解开的<br>
链式前向星的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>数组开<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>∗</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">maxn*maxn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span></span></span></span>就好了，毕竟是二维平面转一维。</p>
<hr>
<p>关于最小覆盖<br>
在这个题目中，最小覆盖=最小割=最大流。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define INF 1000000000000
#define RP pair&lt;long long,long long&gt;
#define maxn 500
#define x first
#define y second
using namespace std;
ll n,m;
ll ux[maxn&lt;&lt;2],uy[maxn&lt;&lt;2];
ll uxn,uyn;
ll s,t,ans;
ll d[maxn],l,r,q[maxn];
ll cnt=1,hd[maxn];
pair&lt;RP,RP&gt; a[maxn];
struct Node{
    ll nx,to,dis;
}e[maxn*maxn*4];

inline ll read(){
    ll xx=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|=c=='-',c=getchar();
    while(isdigit(c))
        xx=(xx&lt;&lt;1)+(xx&lt;&lt;3)+(c^48),c=getchar();
    return f?-xx:xx;
}

inline ll mn(ll u,ll v){
    return u&lt;v?u:v;
}

inline void add(ll u,ll v,ll w){
    e[++cnt].to=v;
    e[cnt].nx=hd[u];
    e[cnt].dis=w;
    hd[u]=cnt;
}

inline ll bfs(){
    memset(d,0,sizeof(d));
    d[s]=1;
    q[l=r=1]=s;
    while(l&lt;=r){
        ll u=q[l++];
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to;
            if(e[i].dis&amp;&amp;!d[to])
                q[++r]=to,d[to]=d[u]+1;
        }
    }
    return d[t];
}

inline ll dfs(ll u,ll limit){
    if(u==t)      return limit;
    ll flow=0;
    for(register int i=hd[u];i&amp;&amp;limit;i=e[i].nx){
        ll to=e[i].to;
        if(d[to]==d[u]+1&amp;&amp;e[i].dis){
            ll fj=dfs(to,mn(limit,e[i].dis));
            e[i].dis-=fj;
            e[i^1].dis+=fj;
            flow+=fj;
            limit-=fj;
        }
    }
    if(!flow)    d[u]=0;
    return flow;
}

int main(){
    n=read();m=read();
    for(register int i=1;i&lt;=m;++i){
        a[i].x.x=read();
        a[i].x.y=read();
        a[i].y.x=read();
        a[i].y.y=read();
        ++a[i].y.x;
        ++a[i].y.y;
        ux[++uxn]=a[i].x.x;
        uy[++uyn]=a[i].x.y;
        ux[++uxn]=a[i].y.x;
        uy[++uyn]=a[i].y.y;
    }
    ux[++uxn]=n+1,
    uy[++uyn]=n+1;
    sort(ux+1,ux+uxn+1);
    sort(uy+1,uy+uyn+1);
    uxn=unique(ux+1,ux+uxn+1)-ux-1;
    uyn=unique(uy+1,uy+uyn+1)-uy-1;
    s=0,t=uxn+uyn+1;
    for(register int i=1;i&lt;=m;++i){
        a[i].x.x=lower_bound(ux+1,ux+uxn+1,a[i].x.x)-ux;
        a[i].x.y=lower_bound(uy+1,uy+uyn+1,a[i].x.y)-uy;
        a[i].y.x=lower_bound(ux+1,ux+uxn+1,a[i].y.x)-ux;
        a[i].y.y=lower_bound(uy+1,uy+uyn+1,a[i].y.y)-uy;
        for(register int j=a[i].x.x;j&lt;a[i].y.x;++j)
            for(register int k=a[i].x.y;k&lt;a[i].y.y;++k)
                add(j,k+uxn,INF),add(k+uxn,j,0);
    }
    for(register int i=1;i&lt;uxn;++i)    add(s,i,ux[i+1]-ux[i]),add(i,s,0);
    for(register int i=1;i&lt;uyn;++i)    add(i+uxn,t,uy[i+1]-uy[i]),add(t,i+uxn,0);
    while(bfs())
        ans+=dfs(s,INF);
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2774 方格取数问题]]></title>
        <id>https://FaineX.github.io/post/p2774-fang-ge-qu-shu-wen-ti/</id>
        <link href="https://FaineX.github.io/post/p2774-fang-ge-qu-shu-wen-ti/">
        </link>
        <updated>2021-07-12T12:49:34.000Z</updated>
        <content type="html"><![CDATA[<p>网络流最小割问题。</p>
<blockquote>
<p>做了狼和羊后一脸蒙的被拉去做了这道题。开局继续蒙。</p>
</blockquote>
<p><s>反正上课也没有听懂</s>，只依稀记得一个什么奇数点放一边，偶数点放一边，建立二分图。<br>
建完边之后，考虑继续连边，将所有可能产生影响的边连接在一起，这里只要把黑点连向白点就可以了。<br>
因为最开始在构建这个网络流的时候，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>-&gt;黑-&gt;白-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>，白连向黑你想干什么啊，河水逆流？</p>
<p>然后然后如果只看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的奇偶性的话肯定会出问题，因为你就相当于不会影响你上下的格子啦。</p>
<p>这道题暂时没有出任何问题！撒花～</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll int
#define INF 1000000000
#define maxn 43200
using namespace std;
ll m,n,a[110][110],cnt=1,hd[maxn];
ll s,t,l,r;
struct Node{
    ll nx,to,dis;
}e[maxn&lt;&lt;2];
ll ff[5][4]={{0,1},{0,-1},{1,0},{-1,0}};
ll d[maxn],ans,q[maxn];
ll sum;

inline ll read(){
    ll x=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|c=='-',c=getchar();
    while(isdigit(c))
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return f?-x:x;
}

inline ll sm(ll u,ll v){
    return (u-1)*m+v;
}

inline void add(ll u,ll v,ll w){
    e[++cnt].to=v;
    e[cnt].nx=hd[u];
    e[cnt].dis=w;
    hd[u]=cnt;
}

inline ll bfs(){
    memset(d,0,sizeof(d));
    l=r=1;
    q[l]=s;
    d[s]=1;
    while(l&lt;=r){
        ll u=q[l++];
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to;
            if(e[i].dis&amp;&amp;!d[to]){
                q[++r]=to;
                d[to]=d[u]+1;
            }
        }

    }
    return d[t];
}

inline ll dfs(ll u,ll limit){
    if(u==t)    return limit;
    ll flow=0;
    for(register int i=hd[u];i&amp;&amp;limit;i=e[i].nx){
        ll to=e[i].to;
        if(e[i].dis&amp;&amp;d[to]==d[u]+1){
            ll fj=dfs(to,min(limit,e[i].dis));
            e[i].dis-=fj;
            e[i^1].dis+=fj;
            flow+=fj;
            limit-=fj;
        }       
    }
    if(!flow)   d[u]=0;
    return flow;
}

int main(){
    n=read();m=read();
    s=n*m*2+1;t=n*m*2+2;
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            a[i][j]=read(),sum+=a[i][j];
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            if((i+j)&amp;1){
                add(s,sm(i,j),a[i][j]);
                add(sm(i,j),s,0);
            }
            else{
                add(sm(i,j),t,a[i][j]);
                add(t,sm(i,j),0);
            }
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            if((i+j)&amp;1){
                for(register int k=0;k&lt;=3;++k){
                    ll dx=i+ff[k][0];
                    ll dy=j+ff[k][1];
                    if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m)
                        add(sm(i,j),sm(dx,dy),INF),
                        add(sm(dx,dy),sm(i,j),0);
                }    
            }
            
    while(bfs())
        ans+=dfs(s,INF);
    printf(&quot;%d\n&quot;,sum-ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2598 [ZJOI2009]狼和羊的故事]]></title>
        <id>https://FaineX.github.io/post/p2598-zjoi2009lang-he-yang-de-gu-shi/</id>
        <link href="https://FaineX.github.io/post/p2598-zjoi2009lang-he-yang-de-gu-shi/">
        </link>
        <updated>2021-07-12T11:48:12.000Z</updated>
        <content type="html"><![CDATA[<p>网络最大流。</p>
<blockquote>
<p>前言：上课<s>滑水</s>，晚上做题一脸蒙，感谢隔壁的帮助（）</p>
</blockquote>
<p>修建栏杆相当于是割断了狼和羊之间的联系方式，即割掉了一条边。<strong>在网格图中，建边的方式为由现在所在的格子向周围四个方向的格子连一条边。</strong>（理论上建立反向边比较赘余，但是因为在跑 Dinic 过程中涉及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>（本条边）和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∧</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i \land 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（反向边）的使用，所以还是建上吧！)因此，在网络流中，要求割最少的边，使得网络不流通，这不就是<strong>网络流最小割问题</strong>嘛？</p>
<blockquote>
<p>最小割<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span>最大流</p>
</blockquote>
<p>所以在建图以后直接跑 Dinic 就好了。</p>
<p>当当当当然，只知道建立网格图的网络流肯定是不够的，狼和羊之间的关系应该怎么处理呢？</p>
<blockquote>
<p>最小割问题指的是，割去一些边之后，源点到汇点不再流通。</p>
</blockquote>
<p>这里要求一定要把狼和羊严格隔开，距离无法隔开他们，也就是说即使他们隔着很多个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的格子，也是可以互相到达的！这就不满足题目条件了。</p>
<p>应该就很明显了，这道题就是裸的网络流最小割问题欸。</p>
<hr>
<p>总结：</p>
<ul>
<li>二维图中用一个数字存储一个坐标：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>m</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">(i-1)*m+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></li>
<li>因为是二，维，图，所以建图的数组要开<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>∗</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">maxn*maxn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span></span></span></span>！</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>的初始值应该赋值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因为你在跑 Dinic 的时候，以下这一段容易出事：</li>
</ul>
<pre><code class="language-cpp">ll fj=dfs(to,min(e[i].dis,limit));
e[i].dis-=fj;
e[i^1].dis+=fj;
</code></pre>
<ul>
<li>加边一定要加反向边啊啊啊！</li>
</ul>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define maxn 42100
#define INF 1000000000
using namespace std;
ll n,m;
ll q[maxn],l,r,d[maxn];
ll a[110][110];
ll ans;
ll s,t;
ll cnt=1,hd[maxn];
ll fx[5][3]={{0,1},{0,-1},{1,0},{-1,0}};
struct Node{
    ll nx,to,dis;
}e[maxn*4];

inline ll read(){
    ll x=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|=c=='-',c=getchar();
    while(isdigit(c))
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return f?-x:x;
}

inline ll sm(ll u,ll v){
    return (u-1)*m+v;
}

inline void add(ll u,ll v,ll w){
    e[++cnt].to=v;
    e[cnt].dis=w;
    e[cnt].nx=hd[u];
    hd[u]=cnt;
}

inline ll bfs(){
    memset(d,0,sizeof(d));
    l=r=1;
    q[l]=s;
    d[s]=1;
    while(l&lt;=r){
        ll u=q[l++];
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to;
            if(!d[to]&amp;&amp;e[i].dis){
                d[to]=d[u]+1;
                q[++r]=to;
            }
        }
    }
    return d[t];
}

inline ll dfs(ll u,ll limit){
    if(u==t)
        return limit;
    ll flow=0;
    for(register int i=hd[u];i&amp;&amp;limit;i=e[i].nx){
        ll to=e[i].to;
        if(e[i].dis&amp;&amp;d[to]==d[u]+1){
            ll fj=dfs(to,min(e[i].dis,limit));
            e[i].dis-=fj;
            e[i^1].dis+=fj;
            limit-=fj;
            flow+=fj;
        }
    }
    if(!flow)   d[u]=0;
    return flow;
}

int main(){
    n=read();m=read();
    s=n*m*2+1,t=n*m*2+2;
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            a[i][j]=read();
    for(register int i=1;i&lt;=n;++i){
        for(register int j=1;j&lt;=m;++j){
            if(a[i][j]==2){
                add(s,sm(i,j),INF);
                add(sm(i,j),s,0);   

            }
            else if(a[i][j]==1){
                add(sm(i,j),t,INF);
                add(t,sm(i,j),0);
            }
        }
    }        
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            for(register int k=0;k&lt;=3;++k){
                ll dx=i+fx[k][0];
                ll dy=j+fx[k][1];
                if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m)
                    add(sm(i,j),sm(dx,dy),1),
                    add(sm(dx,dy),sm(i,j),0);
            }       
    while(bfs())
        ans+=dfs(s,INF);
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[平衡树]]></title>
        <id>https://FaineX.github.io/post/ping-heng-shu/</id>
        <link href="https://FaineX.github.io/post/ping-heng-shu/">
        </link>
        <updated>2021-07-11T13:25:12.000Z</updated>
        <content type="html"><![CDATA[<p>这是一篇个人笔记，不希望大家学习。</p>
<h3 id="treap">Treap</h3>
<p>Treap是一个非常非常好写<s>只是略微看运气</s>的平衡树写法。<br>
先说一句，这篇随笔是写个 XF 看的啦，不是属于正式的算法介绍，因此<s>你们看不看的懂我也不能保证啦</s></p>
<h4 id="一">一、</h4>
<p>平衡树基于二叉搜索树，而对于一颗二叉搜索树，上面的所有节点均满足：左儿子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span>节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span>右儿子，因此任意一颗平衡树一样的也有这样的性质。</p>
<h4 id="二">二、</h4>
<p>为了降低时间复杂度，Treap总是先遍历优先度高的节点，确定优先度的方法就是在建立一个新节点时，对它随机一个新节点。<br>
因此，在每一次删除或者加入操作时，我们也要维护它的这个性质，这就要使用 rotate 了。</p>
<h4 id="三-rotate旋转函数">三、Rotate：旋转函数</h4>
<p>可以选择左旋或者右旋，每次都将改变右/左儿子与其父亲的深度关系。<br>
<s>根据代码模拟下不就好了嘛，放什么图啊</s></p>
<pre><code class="language-cpp">inline void rotate(ll &amp;id,ll d){//direction
    ll tmp=ch[id][d^1];//这里解释一下：d^1可以使0变1，1变0
    ch[id][d^1]=ch[tmp][d];
    ch[tmp][d]=id;
    id=tmp;
    pushup(id);
    pushup(ch[id][d]);
}
</code></pre>
<h4 id="四">四、</h4>
<p>新建节点：</p>
<pre><code class="language-cpp">inline ll New(ll x){
    val[++tot]=x;
    dat[tot]=rand();
    size[tot]=cnt[tot]=1;
    return tot;   
}
inline void build(){
    root=New(-INF),ch[root][1]=New(INF);
    pushup(root);
}
inline void insert(ll &amp;id,ll v){
    if(!id){
        id=New(v);
        return;
    }
    if(val[id]==v)  ++cnt[id];
    else{
        kk=v&lt;val[id]?0:1;
        insert(ch[id][kk],v);
        if(dat[ch[id][kk]]&gt;dat[id])
            rotate(id,kk^1);
    }
    pushup(id);
}
</code></pre>
<p>更新信息：</p>
<pre><code class="language-cpp">inline void pushup(ll x){
    size[x]=size[ch[x][1]]+size[ch[x][0]]+cnt[x];
}
</code></pre>
<p>删除节点：</p>
<pre><code class="language-cpp">inline void remove(ll &amp;id,ll x){
    if(!id)             return;
    else{
        if(val[id]==x){
            if(cnt[id]&gt;1){
                --cnt[id];
                pushup(id);
                return;
            }   
            else{
                if(ch[id][0]||ch[id][1]){
                    if(!ch[id][1]||dat[ch[id][0]]&gt;dat[ch[id][1]])
                        rotate(id,1),remove(ch[id][1],x);
                    else   
                        rotate(id,0),remove(ch[id][0],x);
                    pushup(id);
                }
                else    id=0;
                return;
            }
        }
    }   
    kk=x&lt;val[id]?0:1;
    remove(ch[id][kk],x);
    pushup(id);   
}
</code></pre>
<p>查分/查排名</p>
<pre><code class="language-cpp">
inline ll getrank(ll id,ll x){
    if(!id)
        return -INF;
    if(val[id]==x)
        return size[ch[id][0]]+1;
    if(x&lt;val[id])
        return getrank(ch[id][0],x);
    else    
        return getrank(ch[id][1],x)+size[ch[id][0]]+cnt[id];
}

inline ll getmark(ll id,ll x){
    if(!id)     return INF;
    if(x&lt;=size[ch[id][0]])
        return getmark(ch[id][0],x);
    if(x&lt;=size[ch[id][0]]+cnt[id])
        return val[id];
    return getmark(ch[id][1],x-size[ch[id][0]]-cnt[id]);
}   
</code></pre>
<p>查前驱</p>
<pre><code class="language-cpp">inline ll pre(ll x){
    ll id=root,prev;
    while(id){
        if(val[id]&lt;x)
            prev=val[id],id=ch[id][1];
        else
            id=ch[id][0];
    }
    return prev;
}
</code></pre>
<blockquote>
<p>这里如果当前节点的值比要寻找的值小的话，根据二叉搜索树的规则，应该选择往右边找，是否有更接近的值；如果大于的话，当然往左边找啦</p>
</blockquote>
<p>后继把所有符号反过来就好啦。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hi！]]></title>
        <id>https://FaineX.github.io/post/hi/</id>
        <link href="https://FaineX.github.io/post/hi/">
        </link>
        <updated>2021-07-11T12:13:17.000Z</updated>
        <content type="html"><![CDATA[<p>关于这个博客。</p>
<p>XeniaF 是一位很菜很菜什么都不会的OIER。</p>
<ul>
<li>标有“随笔”的文章，请勿学习里面的任何东西</li>
<li>标有“算法”或者“题解”的文章，如有错误敬请指出。</li>
<li>请勿联系 XeniaF ，包括各大信息网站上面。<br>
<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1270 “访问”美术馆]]></title>
        <id>https://FaineX.github.io/post/p1270-fang-wen-mei-zhu-guan/</id>
        <link href="https://FaineX.github.io/post/p1270-fang-wen-mei-zhu-guan/">
        </link>
        <updated>2021-07-11T12:02:05.000Z</updated>
        <content type="html"><![CDATA[<p>典型的树形DP。</p>
<p>这题的建树方式非常新颖</p>
<p>因为是深度优先搜索输入</p>
<p>所以一个编号为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的节点</p>
<p>如果它里面有画那就说明它是叶子结点</p>
<p>如果它没有话那么就继续输入它的左儿子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和右儿子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x*2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>反正题目给的输入是按深搜的顺序</p>
<p>那么我们也不妨用深搜的方式输入！</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
ll t,n,m,dp[1005][605];
struct node{
    ll tm,pc;
}e[5005];
inline ll read(){
    ll x=0,f=0;
    char c=getchar();
    while(!isdigit(c))
        f|=c=='-',c=getchar();
    while(isdigit(c))
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return f?-x:x;
}
inline void read(ll a){
    e[a].tm=read()*2;
    e[a].pc=read();
    if(!e[a].pc){
        read(a&lt;&lt;1);
        read(a&lt;&lt;1|1);
    }
}
inline void dfs(ll x,ll y){
    if(dp[x][y]||!y)    return;
    if(e[x].pc){
        dp[x][y]=min(e[x].pc,(y-e[x].tm)/5);
        return;
    }
    for(register int i=0;i&lt;=y-e[x].tm;++i){
        dfs(x&lt;&lt;1,i);
        dfs(x&lt;&lt;1|1,y-e[x].tm-i);
        dp[x][y]=max(dp[x][y],dp[x&lt;&lt;1][i]+dp[x&lt;&lt;1|1][y-e[x].tm-i]);
    }
}

signed main(){
    memset(dp,0,sizeof(dp));
    t=read()-1;
    read(1);
    dfs(1,t);
    printf(&quot;%lld\n&quot;,dp[1][t]);
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>