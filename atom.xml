<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://FaineX.github.io</id>
    <title>For XeniaF</title>
    <updated>2021-07-17T12:41:26.541Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://FaineX.github.io"/>
    <link rel="self" href="https://FaineX.github.io/atom.xml"/>
    <subtitle>(☆▽☆)</subtitle>
    <logo>https://FaineX.github.io/images/avatar.png</logo>
    <icon>https://FaineX.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, For XeniaF</rights>
    <entry>
        <title type="html"><![CDATA[数论]]></title>
        <id>https://FaineX.github.io/post/shu-lun/</id>
        <link href="https://FaineX.github.io/post/shu-lun/">
        </link>
        <updated>2021-07-17T09:48:21.000Z</updated>
        <content type="html"><![CDATA[<p>数论。</p>
<h3 id="一-前置知识">一、前置知识</h3>
<ul>
<li>常见的积性函数解释：<br>
1）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span>：欧拉函数<br>
2）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>：莫比乌斯函数<br>
3）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mo>[</mo><mi>n</mi><mo>=</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\varepsilon (n) = [n = 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>：<br>
4）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">id(n) = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>：</li>
</ul>
<hr>
<h3 id="二-欧拉函数varphi">二、欧拉函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span></h3>
<ul>
<li>定义: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 表示小于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的正整数中与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>互质的数的数目。</li>
<li>通式略，证明如下：
<blockquote>
<p>1）对于任意一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>p</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">p^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>为质数），有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><msup><mi>p</mi><mi>k</mi></msup><mo>)</mo><mo>=</mo><msup><mi>p</mi><mi>k</mi></msup><mo>(</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>p</mi></mfrac><mo>)</mo><mo>=</mo><msup><mi>p</mi><mi>k</mi></msup><mo>−</mo><msup><mi>p</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\varphi(p^k) = p^k(1 - \frac{1}{p}) = p^k - p^ {k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。因为要使得一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>p</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">p^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>有公因数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>必须是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>的倍数，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>p</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">p^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>中一共有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msup><mi>p</mi><mi>k</mi></msup><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{p^k}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.576136em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.095028em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9270285714285713em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>的倍数，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><msup><mi>p</mi><mi>k</mi></msup><mo>)</mo><mo>=</mo><msup><mi>p</mi><mi>k</mi></msup><mo>−</mo><msup><mi>p</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\varphi(p^k) = p^k - p^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。<br>
2）对于任意一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是合数），根据积性函数的性质，分解质因子累乘即可。</p>
</blockquote>
</li>
<li>性质选证<br>
1）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></msub><mi>φ</mi><mo>(</mo><mi>d</mi><mo>)</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\sum_{d|n}\varphi(d) = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.22471em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>
<blockquote>
<p>将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>中的每个数写为分子，分母均写为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，约分成最简分数。以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>为例子，约分后如下：</p>
</blockquote>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>6</mn></mfrac><mo separator="true">,</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mo separator="true">,</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo separator="true">,</mo><mfrac><mn>2</mn><mn>3</mn></mfrac><mo separator="true">,</mo><mfrac><mn>5</mn><mn>6</mn></mfrac><mo separator="true">,</mo><mfrac><mn>1</mn><mn>1</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{6},\frac{1}{3},\frac{1}{2},\frac{2}{3},\frac{5}{6},\frac{1}{1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
可以很神奇的发现分子恰好就是对于每个分母<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>，在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,d-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>互质，证毕。</li>
</ul>
<hr>
<h3 id="三-莫比乌斯函数">三、莫比乌斯函数</h3>
<ul>
<li>定义：对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mu(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>有平方数因子则函数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，否则如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>有奇数个质因子则为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>否则为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
<li>例题：[中山市选2011]完全平方数
<blockquote>
<p>这里所谓的容斥其实就是为了让结果符合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mu(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的定义，例子中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>3</mn><mo>∗</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">2*3*5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，结果必须要等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，也是为了维护<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mu(3) = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>的定义。<br>
还有一种理解方式就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>−</mo><mi>b</mi><msup><mo>)</mo><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">(a-b)^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，去掉第一项即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mn>3</mn><mn>0</mn></msubsup></mrow><annotation encoding="application/x-tex">C_3^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span>，也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span>，就符合定义了。</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3980 [NOI2008] 志愿者招募&P1251 餐巾计划问题]]></title>
        <id>https://FaineX.github.io/post/p3980-noi2008-zhi-yuan-zhe-zhao-mu/</id>
        <link href="https://FaineX.github.io/post/p3980-noi2008-zhi-yuan-zhe-zhao-mu/">
        </link>
        <updated>2021-07-17T09:41:46.000Z</updated>
        <content type="html"><![CDATA[<p>最小费用最大流。</p>
<p>请老实打<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">EK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>！！！</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define INF 1000000000000
#define maxn 10010
using namespace std;
ll n,m,c[maxn];
ll cnt=1,hd[maxn];
ll ans,s,t;
ll pos[maxn],pre[maxn],pi[maxn];
ll dis[maxn];
ll vit[maxn];
struct Node{
    ll nx,to,dis,val;
}e[maxn&lt;&lt;1];
struct NODE{
    ll s,t,c;
}a[maxn&lt;&lt;1];
queue&lt;ll&gt;q;

inline ll read(){
    ll x=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|=c=='-',c=getchar();
    while(isdigit(c))
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return f?-x:x;
}

inline void add(ll u,ll v,ll w,ll val){
    e[++cnt].to=v;
    e[cnt].nx=hd[u];
    e[cnt].dis=w;
    e[cnt].val=val;
    hd[u]=cnt;
}

inline int spfa(){
    for(register int i=1;i&lt;=t;++i)
        vit[i]=0,dis[i]=INF;
    vit[s]=1,dis[s]=0,
    q.push(s),pi[s]=INF;
    while(!q.empty()){
        ll u=q.front();q.pop();
        vit[u]=0;
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to;
            if(e[i].dis&amp;&amp;dis[to]&gt;dis[u]+e[i].val){
                dis[to]=dis[u]+e[i].val;
                pre[to]=u;
                pos[to]=i;
                pi[to]=min(pi[u],e[i].dis);
                if(!vit[to]){
                    vit[to]=1;
                    q.push(to);
                }
            }
        }
    }
    return (dis[t]!=INF);
}

// inline int spfa(){
//     for(register int i=1;i&lt;=t;++i)
//         vit[i]=0,dis[i]=INF;
//     q.push(s);
//     vit[s]=1,dis[s]=0;
//     pi[s]=INF;
//     while(!q.empty()){
//         ll u=q.front();q.pop();
//         vit[u]=0;
//         for(register int i=hd[u];i;i=e[i].nx){
//             ll to=e[i].to,val=e[i].val;
//             if(e[i].dis&amp;&amp;dis[to]&gt;dis[u]+val){
//                 dis[to]=dis[u]+val;
//                 pos[to]=i;
//                 pre[to]=u;
//                 pi[to]=min(pi[u],e[i].dis);
//                 if(!vit[to]){
//                     vit[to]=1;
//                     q.push(to);
//                 }
//             }
//         }
//     }
//     return (dis[t]!=INF);
// }

int main(){
    n=read();m=read();
    s=2*n,t=s+1;
    for(register int i=1;i&lt;=n;++i)
        c[i]=read();
    for(register int i=1;i&lt;=m;++i){
        a[i].s=read();a[i].t=read();a[i].c=read();
        add(a[i].s,a[i].t+1,INF,a[i].c),
        add(a[i].t+1,a[i].s,0,-a[i].c);
    }
    for(register int i=1;i&lt;=n;++i)
        add(i,i+1,INF-c[i],0),
        add(i+1,i,0,0);
    add(s,1,INF,0),add(1,s,0,0),add(n+1,t,INF,0),add(t,n+1,0,0);
    ans=0;
    while(spfa()){
        ans+=dis[t]*pi[t];
        for(register int i=t;i!=s;i=pre[i]){
            e[pos[i]].dis-=pi[t];
            e[pos[i]^1].dis+=pi[t];
        }
    }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define INF 1000000000000
#define maxn 100000
using namespace std;
ll N,a[maxn];
ll p,m,f,n,ss;
ll s,t;
ll ans;
ll pi[maxn],pos[maxn],pre[maxn];
ll dis[maxn];
struct Node{
    ll nx,to,val,dis;
}e[maxn&lt;&lt;2];
ll cnt=1,hd[maxn];
ll vit[maxn];
queue&lt;ll&gt;q;

inline ll read(){
    ll x=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|=c=='-',c=getchar();
    while(isdigit(c))
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return f?-x:x;
}

inline void add(ll u,ll v,ll dis,ll vl){
    e[++cnt].to=v;
    e[cnt].nx=hd[u];
    e[cnt].dis=dis;
    e[cnt].val=vl;
    hd[u]=cnt;
}

inline ll sm(ll k){
    return k+N;
}

inline int spfa(){
    for(register int i=1;i&lt;=t;++i)
        vit[i]=0,dis[i]=INF;
    q.push(s);
    vit[s]=1,dis[s]=0;
    pi[s]=INF;
    while(!q.empty()){
        ll u=q.front();q.pop();
        vit[u]=0;
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to,val=e[i].val;
            if(e[i].dis&amp;&amp;dis[to]&gt;dis[u]+val){
                dis[to]=dis[u]+val;
                pre[to]=i;
                pos[to]=u;
                pi[to]=min(pi[u],e[i].dis);
                if(!vit[to]){
                    vit[to]=1;
                    q.push(to);
                }
            }
        }
    }
    return (dis[t]!=INF);
}

int main(){
    N=read();
    for(register int i=1;i&lt;=N;++i)
        a[i]=read();
    p=read();m=read();f=read();n=read();ss=read();
    t=N*3+2;
    s=t-1;
    for(register int i=1;i&lt;=N;++i){
        add(s,i,a[i],0),
        add(i,s,0,0),
        add(sm(i),t,a[i],0),
        add(t,sm(i),0,0);
        if(i+1&lt;=N)
            add(i,i+1,INF,0),
            add(i+1,i,0,0);
        if(i+m&lt;=N)
            add(i,sm(i+m),INF,f),
            add(sm(i+m),i,0,-f);
        if(i+n&lt;=N)
            add(i,sm(i+n),INF,ss),
            add(sm(i+n),i,0,-ss);
        add(s,sm(i),INF,p),
        add(sm(i),s,0,-p);
    }   
    ans=0;
    while(spfa()){
        ans+=pi[t]*dis[t];
        for(register int i=t;i!=s;i=pos[i]){
            e[pre[i]].dis-=pi[t];
            e[pre[i]^1].dis+=pi[t];
        }
    }        
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络流]]></title>
        <id>https://FaineX.github.io/post/wang-luo-liu/</id>
        <link href="https://FaineX.github.io/post/wang-luo-liu/">
        </link>
        <updated>2021-07-14T11:44:55.000Z</updated>
        <content type="html"><![CDATA[<p>题目汇总。</p>
<hr>
<h2 id="最小割">最小割</h2>
<h4 id="p2598-zjoi2009狼和羊的故事">P2598 [ZJOI2009]狼和羊的故事</h4>
<blockquote>
<ul>
<li>修建栏杆相当于是割断了狼和羊之间的联系方式，即割掉了一条边。<strong>在网格图中，建边的方式为由现在所在的格子向周围四个方向的格子连一条边。</strong>（理论上建立反向边比较赘余，但是因为在跑 Dinic 过程中涉及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>（本条边）和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∧</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i \land 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（反向边）的使用，所以建。)因此，在网络流中，要求割最少的边，使得网络不流通，为<strong>网络流最小割问题</strong>。需要用到的定理为：最小割<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span>最大流。建图以后跑 Dinic 就好了。</li>
<li>最小割问题指的是，割去一些边之后，源点到汇点不再流通。这里要求一定要把狼和羊严格隔开，距离无法隔开他们，也就是说即使他们隔着很多个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的格子，也是可以互相到达的！这就不满足题目条件了。</li>
</ul>
</blockquote>
<h4 id="p2774-方格取数问题">P2774 方格取数问题</h4>
<blockquote>
<ul>
<li>奇数点放一边，偶数点放一边，建立二分图。建完边后，考虑继续连边，将所有可能产生影响的边连接在一起，这里只要把黑点连向白点就可以了。因为最开始在构建这个网络流的时候，方向已经定为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>-&gt;黑-&gt;白-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>了。</li>
<li>如果只看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的奇偶性的话会出问题，因为就相当于不会影响上下的格子。</li>
</ul>
</blockquote>
<h4 id="cf1198e-rectangle-painting-2">CF1198E Rectangle Painting 2</h4>
<blockquote>
<ul>
<li>把一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>∗</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">h*w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的矩形区域覆盖的代价是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\min(h,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>，因此选择一个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">1*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的区间显然非常优秀。如果多个区间可以合并的话，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>显然代价等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">n* \min(1,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k* \min(n,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，并且数据中区间所占行数和列数离散化后又不是很多，因此可以这么做！</li>
<li>关于离散化<br>
1）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>x</mi><mi>n</mi><mi mathvariant="normal">，</mi><mi>u</mi><mi>y</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">uxn，uyn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">n</span></span></span></span>保存的是离散化后数组总个数，不是最大值；<br>
2）通过画图可以发现，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>u</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ux[i+1]-ux[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>确实包含了所有的矩形，但是有可能把把两个矩形切成三个矩形；<br>
3）至于为什么要变作闭右开区间，因为这样确实可以很好的覆盖所有的数，是一种技巧。</li>
<li>关于最小覆盖<br>
在这个题目中，最小覆盖=最小割=最大流。</li>
</ul>
</blockquote>
<hr>
<h2 id="最小费用最大流">最小费用最大流</h2>
<h4 id="p3159-cqoi2012交换棋子">P3159 [CQOI2012]交换棋子</h4>
<blockquote>
<ul>
<li>题目涉及黑白棋子和两种状态，均考虑显然比较繁杂。暂且先不管白棋子和不变色的黑棋子，将所有初始状态就是黑棋子的点与源点相连，最终状态是黑棋子的点与汇点相连。因为黑棋子的交换可以看作移动，显然只有端点只交换了一次其他中间点交换了两次因此建边时流量应<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>。</li>
<li>建边方式如下：<br>
1）连源汇，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，表示有待匹配；<br>
2）中间点，初始状态与最终状态相连，流量为交换次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>，费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；<br>
3）初始状态与最终状态不同，且可交换次数为奇数的黑棋，单独向最终状态连一条边，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；<br>
4）处理格点，向八个方向连边，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即交换需要付出的代价。</li>
<li>跑模板即可。</li>
</ul>
</blockquote>
<h4 id="p1251-餐巾计划问题">P1251 餐巾计划问题</h4>
<blockquote>
<ul>
<li>题目涉及多种增加当天可利用的餐巾数量的可能，需要一步一步分清况讨论。</li>
<li>建边方式：<br>
1）源点向每一天早上连入一条流量为 INF ，费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>的边：可以购买新的餐巾；<br>
2）源点向每一天晚上连入一条流量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的边：从起点获得脏餐巾，即今天用过了的餐巾；<br>
3）每一天早上向汇点连入一条流量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的边：向汇点提供干净餐巾，如果流满了，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>号节点的餐巾显然是够用的（前几天剩得够多，能够支持今天的消耗）；<br>
4）每一天向快洗<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>天、慢洗<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>天后连流量为 INF ，费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ss</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span>的边：快洗/慢洗</li>
<li>跑最小费用最大流即可。</li>
</ul>
</blockquote>
<h4 id="p3980-noi2008-志愿者招募">P3980 [NOI2008] 志愿者招募</h4>
<blockquote>
<ul>
<li>明显的费用流，注意连边应该要往后多连一个点。</li>
<li>建边方式：<br>
1）第一天连源点，第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>天连汇点<br>
2）每一天向后连一天<br>
3）特殊时间段起点连向终点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span></li>
<li>最小费用最大流。</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3159 [CQOI2012]交换棋子]]></title>
        <id>https://FaineX.github.io/post/p3159-cqoi2012jiao-huan-qi-zi/</id>
        <link href="https://FaineX.github.io/post/p3159-cqoi2012jiao-huan-qi-zi/">
        </link>
        <updated>2021-07-14T11:42:53.000Z</updated>
        <content type="html"><![CDATA[<p>最小费用最大流。</p>
<p>题目涉及黑白棋子和两种状态，均考虑显然比较繁杂。暂且先不管白棋子和不变色的黑棋子，将所有初始状态就是黑棋子的点与源点相连，最终状态是黑棋子的点与汇点相连。因为黑棋子的交换可以看作移动，显然只有端点只交换了一次其他中间点交换了两次因此建边时流量应<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>。<br>
建边方式如下：<br>
1）连源汇，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，表示有待匹配；<br>
2）中间点，初始状态与最终状态相连，流量为交换次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>，费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；<br>
3）初始状态与最终状态不同，且可交换次数为奇数的黑棋，单独向最终状态连一条边，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；<br>
4）处理格点，向八个方向连边，流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即交换需要付出的代价。<br>
跑模板即可。</p>
<p>注意：<br>
1）依然是数组大小！<br>
2）费用流基本上就是用 spfa 代替了 bfs ，每次通过 spfa 寻找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的最短路，再 dfs 不断增广。<br>
3）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>m</mi><mi mathvariant="normal">，</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sm，ct</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span></span></span></span>数组是用来拆点的，连边的流量就相当于是交换次数。能成功交换的交换次数一定是偶数的，因此如果是奇数那就应该补上原本就有的那次交换。</p>
<ul>
<li>设原来的交换次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2*a+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">2</span></span></span></span>后为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，实际上只会交换<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">2*a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>次，因此应该加边补上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ul>
<p>4）spfa 中的阶层直接由费用进行划分，由于是最短路初始值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，最终判断时也变为了是否等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><br>
5）dfs 中增加了一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">vit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>数组的判断操作，去掉会段错误（暂时不知道为什么<br>
6）玄学弧优化，然而我的出锅了...</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define maxn 5000
#define INF 1000000000000
using namespace std;
ll n,m,a[maxn][maxn],b[maxn][maxn],l[maxn][maxn];
ll si,ti;
ll s,t,p;
ll ff[15][3]={{0,1},{0,-1},{1,0},{-1,0},{-1,1},{1,-1},{1,1},{-1,-1}};
char c[maxn][maxn];
struct Node{
    ll nx,to,dis,val;
}e[maxn&lt;&lt;2];
ll cnt=1,hd[maxn];
ll vit[maxn],dep[maxn],cur[maxn];
ll ansf,anss;
queue&lt;ll&gt;q;

inline ll mn(ll u,ll v){
    return u&lt;v?u:v;
}

inline ll read(){
    ll x=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|=c=='-',c=getchar();
    while(isdigit(c))
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return f?-x:x;
}

inline void add(ll u,ll v,ll w,ll vl){
    e[++cnt].to=v;
    e[cnt].dis=w;
    e[cnt].val=vl;
    e[cnt].nx=hd[u];
    hd[u]=cnt;
}

inline ll sm(ll u,ll v){
    return (u-1)*m+v;
}

inline ll ct(ll u,ll v){
    return (u-1)*m+v+n*m;
}

inline int spfa(){
    for(register int i=1;i&lt;=p;++i)
        vit[i]=0,dep[i]=INF,cur[i]=hd[i];
    q.push(s);
    vit[s]=1,dep[s]=0;
    while(!q.empty()){
        ll u=q.front();q.pop();
        vit[u]=0;
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to,val=e[i].val;
            if(e[i].dis&amp;&amp;dep[to]&gt;dep[u]+val){
                dep[to]=dep[u]+val;
                if(!vit[to]){
                    vit[to]=1;
                    q.push(to);
                }
            }
        }
    }
    return (dep[t]!=INF);
}

inline ll dfs(ll u,ll limit){
    if(u==t)    return limit;
    ll flow=0,fj;
    vit[u]=1;
    for(register int i=hd[u];i;i=e[i].nx){
        ll to=e[i].to;
//        cur[u]=i;
        if((!vit[to]&amp;&amp;e[i].dis&amp;&amp;dep[u]+e[i].val==dep[to])&amp;&amp;(fj=dfs(to,mn(limit,e[i].dis)))&gt;0){
            e[i].dis-=fj;
            e[i^1].dis+=fj;
            flow+=fj;
            limit-=fj;
            if(!limit){
                vit[u]=0;
                break;
            }
        }
    }
    return flow;
}

int main(){
    n=read();m=read();
    s=t-1,p=t=2*n*m+2;
    for(register int i=1;i&lt;=n;++i){
        cin&gt;&gt;c[i];
        for(register int j=1;j&lt;=m;++j)
            a[i][j]=c[i][j-1]-'0',si+=(a[i][j]);
    }
    for(register int i=1;i&lt;=n;++i){
        cin&gt;&gt;c[i];
        for(register int j=1;j&lt;=m;++j)
            b[i][j]=c[i][j-1]-'0',ti+=(b[i][j]);
    }
    if(si!=ti){
        printf(&quot;-1\n&quot;);
        return 0;
    }
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            if(b[i][j]!=a[i][j])
                if(a[i][j])
                    add(s,sm(i,j),1,0),
                    add(sm(i,j),s,0,0),
                    ++ansf;
                else
                    add(ct(i,j),t,1,0), 
                    add(t,ct(i,j),0,0);
    for(register int i=1;i&lt;=n;++i){
        cin&gt;&gt;c[i];
        for(register int j=1;j&lt;=m;++j){
            l[i][j]=c[i][j-1]-'0';
            add(sm(i,j),ct(i,j),l[i][j]&gt;&gt;1,0),
            add(ct(i,j),sm(i,j),0,0);
            if((a[i][j]^b[i][j])&amp;&amp;(l[i][j]&amp;1))
                add(sm(i,j),ct(i,j),1,0),
                add(ct(i,j),sm(i,j),0,0);
            for(register int k=0;k&lt;=7;++k){
                ll dx=i+ff[k][0];
                ll dy=j+ff[k][1];
                if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m)
                    add(ct(i,j),sm(dx,dy),INF,1),
                    add(sm(dx,dy),ct(i,j),0,-1);
            }
        }
            
    }
    while(spfa()){
        ll tik=dfs(s,INF);
        ansf-=tik,anss+=tik*dep[t];
//        cout&lt;&lt;&quot;我好困呜呜呜\n&quot;;
//        cout&lt;&lt;&quot;ans: &quot;&lt;&lt;tik&lt;&lt;endl;
    }
    if(ansf)    puts(&quot;-1&quot;);
    else        printf(&quot;%lld\n&quot;,anss);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2017 [USACO09DEC]Dizzy Cows G]]></title>
        <id>https://FaineX.github.io/post/p2017-usaco09decdizzy-cows-g/</id>
        <link href="https://FaineX.github.io/post/p2017-usaco09decdizzy-cows-g/">
        </link>
        <updated>2021-07-13T11:09:39.000Z</updated>
        <content type="html"><![CDATA[<p>拓扑排序。</p>
<blockquote>
<p>前言：感觉不像网络流或者二分图啊...不会是他们说错了吧啊啊啊，不管了。</p>
</blockquote>
<p>题目大意是要你找到一种定向方法，使图中不存在环。<br>
考虑拓扑排序。<br>
先将入读为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的点加入队列（此时并不考虑无向边），再进行拓扑。<br>
拓扑到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>点时，如果发现有一条无向边，就将它直接定向：现在节点为这条边的起点。</p>
<blockquote>
<p>关于这种做法的正确性<br>
“dfs完成拓扑排序，拓扑这个东西核心就是排序，排什么序呢，将无向图变成一个有向无环图（DAG），这个就是题目的要求吗，双边就不跑，只跑单边，把拓扑序找到，再依次判断方向。对于拓扑序来说，dfs后深度越浅的点，拓扑序越大，然后只将大的指向小的，就不会形成环了。“（@Zxsoul）</p>
</blockquote>
<p>注：</p>
<ul>
<li>使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∧</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a \land 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时注意<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>必须是奇数</li>
<li>当一道题目与 DAG（有向无环图）有关时，考虑拓扑排序。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1198E Rectangle Painting 2]]></title>
        <id>https://FaineX.github.io/post/cf1198e-rectangle-painting-2/</id>
        <link href="https://FaineX.github.io/post/cf1198e-rectangle-painting-2/">
        </link>
        <updated>2021-07-13T09:25:20.000Z</updated>
        <content type="html"><![CDATA[<p>网络流<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span>二分图最小覆盖。</p>
<p>把一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>∗</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">h*w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的矩形区域覆盖的代价是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\min(h,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>，因此选择一个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">1*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的区间显然非常优秀。如果多个区间可以合并的话，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>显然代价等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">n* \min(1,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k* \min(n,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，并且<s>数据中区间所占行数和列数离散化后又不是很多</s>，因此可以这么做！</p>
<hr>
<p>关于离散化</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>x</mi><mi>n</mi><mi mathvariant="normal">，</mi><mi>u</mi><mi>y</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">uxn，uyn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">n</span></span></span></span>保存的是离散化后数组总个数，不是最大值</li>
<li>通过画图可以发现，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>u</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ux[i+1]-ux[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>确实包含了所有的矩形，但是有可能把把两个矩形切成三个矩形</li>
<li>然然后为什么要变作闭右开区间呢，因为这样确实可以很好的覆盖所有的数，自己模拟吧（），但这真的是个技巧欸</li>
</ul>
<p>我居然看懂了！/fad</p>
<hr>
<p>关于数据范围<br>
首先这个500就很玄学啊（我死都不会说我看了题解开的<br>
链式前向星的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>数组开<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>∗</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">maxn*maxn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span></span></span></span>就好了，毕竟是二维平面转一维。</p>
<hr>
<p>关于最小覆盖<br>
在这个题目中，最小覆盖=最小割=最大流。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define INF 1000000000000
#define RP pair&lt;long long,long long&gt;
#define maxn 500
#define x first
#define y second
using namespace std;
ll n,m;
ll ux[maxn&lt;&lt;2],uy[maxn&lt;&lt;2];
ll uxn,uyn;
ll s,t,ans;
ll d[maxn],l,r,q[maxn];
ll cnt=1,hd[maxn];
pair&lt;RP,RP&gt; a[maxn];
struct Node{
    ll nx,to,dis;
}e[maxn*maxn*4];

inline ll read(){
    ll xx=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|=c=='-',c=getchar();
    while(isdigit(c))
        xx=(xx&lt;&lt;1)+(xx&lt;&lt;3)+(c^48),c=getchar();
    return f?-xx:xx;
}

inline ll mn(ll u,ll v){
    return u&lt;v?u:v;
}

inline void add(ll u,ll v,ll w){
    e[++cnt].to=v;
    e[cnt].nx=hd[u];
    e[cnt].dis=w;
    hd[u]=cnt;
}

inline ll bfs(){
    memset(d,0,sizeof(d));
    d[s]=1;
    q[l=r=1]=s;
    while(l&lt;=r){
        ll u=q[l++];
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to;
            if(e[i].dis&amp;&amp;!d[to])
                q[++r]=to,d[to]=d[u]+1;
        }
    }
    return d[t];
}

inline ll dfs(ll u,ll limit){
    if(u==t)      return limit;
    ll flow=0;
    for(register int i=hd[u];i&amp;&amp;limit;i=e[i].nx){
        ll to=e[i].to;
        if(d[to]==d[u]+1&amp;&amp;e[i].dis){
            ll fj=dfs(to,mn(limit,e[i].dis));
            e[i].dis-=fj;
            e[i^1].dis+=fj;
            flow+=fj;
            limit-=fj;
        }
    }
    if(!flow)    d[u]=0;
    return flow;
}

int main(){
    n=read();m=read();
    for(register int i=1;i&lt;=m;++i){
        a[i].x.x=read();
        a[i].x.y=read();
        a[i].y.x=read();
        a[i].y.y=read();
        ++a[i].y.x;
        ++a[i].y.y;
        ux[++uxn]=a[i].x.x;
        uy[++uyn]=a[i].x.y;
        ux[++uxn]=a[i].y.x;
        uy[++uyn]=a[i].y.y;
    }
    ux[++uxn]=n+1,
    uy[++uyn]=n+1;
    sort(ux+1,ux+uxn+1);
    sort(uy+1,uy+uyn+1);
    uxn=unique(ux+1,ux+uxn+1)-ux-1;
    uyn=unique(uy+1,uy+uyn+1)-uy-1;
    s=0,t=uxn+uyn+1;
    for(register int i=1;i&lt;=m;++i){
        a[i].x.x=lower_bound(ux+1,ux+uxn+1,a[i].x.x)-ux;
        a[i].x.y=lower_bound(uy+1,uy+uyn+1,a[i].x.y)-uy;
        a[i].y.x=lower_bound(ux+1,ux+uxn+1,a[i].y.x)-ux;
        a[i].y.y=lower_bound(uy+1,uy+uyn+1,a[i].y.y)-uy;
        for(register int j=a[i].x.x;j&lt;a[i].y.x;++j)
            for(register int k=a[i].x.y;k&lt;a[i].y.y;++k)
                add(j,k+uxn,INF),add(k+uxn,j,0);
    }
    for(register int i=1;i&lt;uxn;++i)    add(s,i,ux[i+1]-ux[i]),add(i,s,0);
    for(register int i=1;i&lt;uyn;++i)    add(i+uxn,t,uy[i+1]-uy[i]),add(t,i+uxn,0);
    while(bfs())
        ans+=dfs(s,INF);
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2774 方格取数问题]]></title>
        <id>https://FaineX.github.io/post/p2774-fang-ge-qu-shu-wen-ti/</id>
        <link href="https://FaineX.github.io/post/p2774-fang-ge-qu-shu-wen-ti/">
        </link>
        <updated>2021-07-12T12:49:34.000Z</updated>
        <content type="html"><![CDATA[<p>网络流最小割问题。</p>
<blockquote>
<p>做了狼和羊后一脸蒙的被拉去做了这道题。开局继续蒙。</p>
</blockquote>
<p><s>反正上课也没有听懂</s>，只依稀记得一个什么奇数点放一边，偶数点放一边，建立二分图。<br>
建完边之后，考虑继续连边，将所有可能产生影响的边连接在一起，这里只要把黑点连向白点就可以了。<br>
因为最开始在构建这个网络流的时候，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>-&gt;黑-&gt;白-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>，白连向黑你想干什么啊，河水逆流？</p>
<p>然后然后如果只看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的奇偶性的话肯定会出问题，因为你就相当于不会影响你上下的格子啦。</p>
<p>这道题暂时没有出任何问题！撒花～</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll int
#define INF 1000000000
#define maxn 43200
using namespace std;
ll m,n,a[110][110],cnt=1,hd[maxn];
ll s,t,l,r;
struct Node{
    ll nx,to,dis;
}e[maxn&lt;&lt;2];
ll ff[5][4]={{0,1},{0,-1},{1,0},{-1,0}};
ll d[maxn],ans,q[maxn];
ll sum;

inline ll read(){
    ll x=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|c=='-',c=getchar();
    while(isdigit(c))
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return f?-x:x;
}

inline ll sm(ll u,ll v){
    return (u-1)*m+v;
}

inline void add(ll u,ll v,ll w){
    e[++cnt].to=v;
    e[cnt].nx=hd[u];
    e[cnt].dis=w;
    hd[u]=cnt;
}

inline ll bfs(){
    memset(d,0,sizeof(d));
    l=r=1;
    q[l]=s;
    d[s]=1;
    while(l&lt;=r){
        ll u=q[l++];
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to;
            if(e[i].dis&amp;&amp;!d[to]){
                q[++r]=to;
                d[to]=d[u]+1;
            }
        }

    }
    return d[t];
}

inline ll dfs(ll u,ll limit){
    if(u==t)    return limit;
    ll flow=0;
    for(register int i=hd[u];i&amp;&amp;limit;i=e[i].nx){
        ll to=e[i].to;
        if(e[i].dis&amp;&amp;d[to]==d[u]+1){
            ll fj=dfs(to,min(limit,e[i].dis));
            e[i].dis-=fj;
            e[i^1].dis+=fj;
            flow+=fj;
            limit-=fj;
        }       
    }
    if(!flow)   d[u]=0;
    return flow;
}

int main(){
    n=read();m=read();
    s=n*m*2+1;t=n*m*2+2;
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            a[i][j]=read(),sum+=a[i][j];
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            if((i+j)&amp;1){
                add(s,sm(i,j),a[i][j]);
                add(sm(i,j),s,0);
            }
            else{
                add(sm(i,j),t,a[i][j]);
                add(t,sm(i,j),0);
            }
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            if((i+j)&amp;1){
                for(register int k=0;k&lt;=3;++k){
                    ll dx=i+ff[k][0];
                    ll dy=j+ff[k][1];
                    if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m)
                        add(sm(i,j),sm(dx,dy),INF),
                        add(sm(dx,dy),sm(i,j),0);
                }    
            }
            
    while(bfs())
        ans+=dfs(s,INF);
    printf(&quot;%d\n&quot;,sum-ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2598 [ZJOI2009]狼和羊的故事]]></title>
        <id>https://FaineX.github.io/post/p2598-zjoi2009lang-he-yang-de-gu-shi/</id>
        <link href="https://FaineX.github.io/post/p2598-zjoi2009lang-he-yang-de-gu-shi/">
        </link>
        <updated>2021-07-12T11:48:12.000Z</updated>
        <content type="html"><![CDATA[<p>网络最大流。</p>
<blockquote>
<p>前言：上课<s>滑水</s>，晚上做题一脸蒙，感谢隔壁的帮助（）</p>
</blockquote>
<p>修建栏杆相当于是割断了狼和羊之间的联系方式，即割掉了一条边。<strong>在网格图中，建边的方式为由现在所在的格子向周围四个方向的格子连一条边。</strong>（理论上建立反向边比较赘余，但是因为在跑 Dinic 过程中涉及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>（本条边）和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∧</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i \land 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（反向边）的使用，所以还是建上吧！)因此，在网络流中，要求割最少的边，使得网络不流通，这不就是<strong>网络流最小割问题</strong>嘛？</p>
<blockquote>
<p>最小割<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span>最大流</p>
</blockquote>
<p>所以在建图以后直接跑 Dinic 就好了。</p>
<p>当当当当然，只知道建立网格图的网络流肯定是不够的，狼和羊之间的关系应该怎么处理呢？</p>
<blockquote>
<p>最小割问题指的是，割去一些边之后，源点到汇点不再流通。</p>
</blockquote>
<p>这里要求一定要把狼和羊严格隔开，距离无法隔开他们，也就是说即使他们隔着很多个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的格子，也是可以互相到达的！这就不满足题目条件了。</p>
<p>应该就很明显了，这道题就是裸的网络流最小割问题欸。</p>
<hr>
<p>总结：</p>
<ul>
<li>二维图中用一个数字存储一个坐标：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>m</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">(i-1)*m+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></li>
<li>因为是二，维，图，所以建图的数组要开<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>∗</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">maxn*maxn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span></span></span></span>！</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>的初始值应该赋值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因为你在跑 Dinic 的时候，以下这一段容易出事：</li>
</ul>
<pre><code class="language-cpp">ll fj=dfs(to,min(e[i].dis,limit));
e[i].dis-=fj;
e[i^1].dis+=fj;
</code></pre>
<ul>
<li>加边一定要加反向边啊啊啊！</li>
</ul>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define maxn 42100
#define INF 1000000000
using namespace std;
ll n,m;
ll q[maxn],l,r,d[maxn];
ll a[110][110];
ll ans;
ll s,t;
ll cnt=1,hd[maxn];
ll fx[5][3]={{0,1},{0,-1},{1,0},{-1,0}};
struct Node{
    ll nx,to,dis;
}e[maxn*4];

inline ll read(){
    ll x=0,f=0;char c=getchar();
    while(!isdigit(c))
        f|=c=='-',c=getchar();
    while(isdigit(c))
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return f?-x:x;
}

inline ll sm(ll u,ll v){
    return (u-1)*m+v;
}

inline void add(ll u,ll v,ll w){
    e[++cnt].to=v;
    e[cnt].dis=w;
    e[cnt].nx=hd[u];
    hd[u]=cnt;
}

inline ll bfs(){
    memset(d,0,sizeof(d));
    l=r=1;
    q[l]=s;
    d[s]=1;
    while(l&lt;=r){
        ll u=q[l++];
        for(register int i=hd[u];i;i=e[i].nx){
            ll to=e[i].to;
            if(!d[to]&amp;&amp;e[i].dis){
                d[to]=d[u]+1;
                q[++r]=to;
            }
        }
    }
    return d[t];
}

inline ll dfs(ll u,ll limit){
    if(u==t)
        return limit;
    ll flow=0;
    for(register int i=hd[u];i&amp;&amp;limit;i=e[i].nx){
        ll to=e[i].to;
        if(e[i].dis&amp;&amp;d[to]==d[u]+1){
            ll fj=dfs(to,min(e[i].dis,limit));
            e[i].dis-=fj;
            e[i^1].dis+=fj;
            limit-=fj;
            flow+=fj;
        }
    }
    if(!flow)   d[u]=0;
    return flow;
}

int main(){
    n=read();m=read();
    s=n*m*2+1,t=n*m*2+2;
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            a[i][j]=read();
    for(register int i=1;i&lt;=n;++i){
        for(register int j=1;j&lt;=m;++j){
            if(a[i][j]==2){
                add(s,sm(i,j),INF);
                add(sm(i,j),s,0);   

            }
            else if(a[i][j]==1){
                add(sm(i,j),t,INF);
                add(t,sm(i,j),0);
            }
        }
    }        
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=m;++j)
            for(register int k=0;k&lt;=3;++k){
                ll dx=i+fx[k][0];
                ll dy=j+fx[k][1];
                if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m)
                    add(sm(i,j),sm(dx,dy),1),
                    add(sm(dx,dy),sm(i,j),0);
            }       
    while(bfs())
        ans+=dfs(s,INF);
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[平衡树]]></title>
        <id>https://FaineX.github.io/post/ping-heng-shu/</id>
        <link href="https://FaineX.github.io/post/ping-heng-shu/">
        </link>
        <updated>2021-07-11T13:25:12.000Z</updated>
        <content type="html"><![CDATA[<p>这是一篇个人笔记，不希望大家学习。</p>
<h3 id="treap">Treap</h3>
<p>Treap是一个非常非常好写<s>只是略微看运气</s>的平衡树写法。<br>
先说一句，这篇随笔是写个 XF 看的啦，不是属于正式的算法介绍，因此<s>你们看不看的懂我也不能保证啦</s></p>
<h4 id="一">一、</h4>
<p>平衡树基于二叉搜索树，而对于一颗二叉搜索树，上面的所有节点均满足：左儿子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span>节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span>右儿子，因此任意一颗平衡树一样的也有这样的性质。</p>
<h4 id="二">二、</h4>
<p>为了降低时间复杂度，Treap总是先遍历优先度高的节点，确定优先度的方法就是在建立一个新节点时，对它随机一个新节点。<br>
因此，在每一次删除或者加入操作时，我们也要维护它的这个性质，这就要使用 rotate 了。</p>
<h4 id="三-rotate旋转函数">三、Rotate：旋转函数</h4>
<p>可以选择左旋或者右旋，每次都将改变右/左儿子与其父亲的深度关系。<br>
<s>根据代码模拟下不就好了嘛，放什么图啊</s></p>
<pre><code class="language-cpp">inline void rotate(ll &amp;id,ll d){//direction
    ll tmp=ch[id][d^1];//这里解释一下：d^1可以使0变1，1变0
    ch[id][d^1]=ch[tmp][d];
    ch[tmp][d]=id;
    id=tmp;
    pushup(id);
    pushup(ch[id][d]);
}
</code></pre>
<h4 id="四">四、</h4>
<p>新建节点：</p>
<pre><code class="language-cpp">inline ll New(ll x){
    val[++tot]=x;
    dat[tot]=rand();
    size[tot]=cnt[tot]=1;
    return tot;   
}
inline void build(){
    root=New(-INF),ch[root][1]=New(INF);
    pushup(root);
}
inline void insert(ll &amp;id,ll v){
    if(!id){
        id=New(v);
        return;
    }
    if(val[id]==v)  ++cnt[id];
    else{
        kk=v&lt;val[id]?0:1;
        insert(ch[id][kk],v);
        if(dat[ch[id][kk]]&gt;dat[id])
            rotate(id,kk^1);
    }
    pushup(id);
}
</code></pre>
<p>更新信息：</p>
<pre><code class="language-cpp">inline void pushup(ll x){
    size[x]=size[ch[x][1]]+size[ch[x][0]]+cnt[x];
}
</code></pre>
<p>删除节点：</p>
<pre><code class="language-cpp">inline void remove(ll &amp;id,ll x){
    if(!id)             return;
    else{
        if(val[id]==x){
            if(cnt[id]&gt;1){
                --cnt[id];
                pushup(id);
                return;
            }   
            else{
                if(ch[id][0]||ch[id][1]){
                    if(!ch[id][1]||dat[ch[id][0]]&gt;dat[ch[id][1]])
                        rotate(id,1),remove(ch[id][1],x);
                    else   
                        rotate(id,0),remove(ch[id][0],x);
                    pushup(id);
                }
                else    id=0;
                return;
            }
        }
    }   
    kk=x&lt;val[id]?0:1;
    remove(ch[id][kk],x);
    pushup(id);   
}
</code></pre>
<p>查分/查排名</p>
<pre><code class="language-cpp">
inline ll getrank(ll id,ll x){
    if(!id)
        return -INF;
    if(val[id]==x)
        return size[ch[id][0]]+1;
    if(x&lt;val[id])
        return getrank(ch[id][0],x);
    else    
        return getrank(ch[id][1],x)+size[ch[id][0]]+cnt[id];
}

inline ll getmark(ll id,ll x){
    if(!id)     return INF;
    if(x&lt;=size[ch[id][0]])
        return getmark(ch[id][0],x);
    if(x&lt;=size[ch[id][0]]+cnt[id])
        return val[id];
    return getmark(ch[id][1],x-size[ch[id][0]]-cnt[id]);
}   
</code></pre>
<p>查前驱</p>
<pre><code class="language-cpp">inline ll pre(ll x){
    ll id=root,prev;
    while(id){
        if(val[id]&lt;x)
            prev=val[id],id=ch[id][1];
        else
            id=ch[id][0];
    }
    return prev;
}
</code></pre>
<blockquote>
<p>这里如果当前节点的值比要寻找的值小的话，根据二叉搜索树的规则，应该选择往右边找，是否有更接近的值；如果大于的话，当然往左边找啦</p>
</blockquote>
<p>后继把所有符号反过来就好啦。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hi！]]></title>
        <id>https://FaineX.github.io/post/hi/</id>
        <link href="https://FaineX.github.io/post/hi/">
        </link>
        <updated>2021-07-11T12:13:17.000Z</updated>
        <content type="html"><![CDATA[<p>关于这个博客。</p>
<p>XeniaF 是一位很菜很菜什么都不会的OIER。</p>
<ul>
<li>标有“随笔”的文章，请勿学习里面的任何东西</li>
<li>标有“算法”或者“题解”的文章，如有错误敬请指出。</li>
<li>请勿联系 XeniaF ，包括各大信息网站上面。<br>
<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em></li>
</ul>
]]></content>
    </entry>
</feed>